.
├── parser
│   ├── example2.rt
│   ├── includes
│   │   └── minirt.h
│   ├── libft
│   │   ├── Includes
│   │   │   └── libft.h
│   │   ├── Makefile
│   │   └── Sources
│   │       ├── free_utils.c
│   │       ├── ft_atoi.c
│   │       ├── ft_atol.c
│   │       ├── ft_bzero.c
│   │       ├── ft_calloc.c
│   │       ├── ft_error.c
│   │       ├── ft_isalnum.c
│   │       ├── ft_isalpha.c
│   │       ├── ft_isascii.c
│   │       ├── ft_isdigit.c
│   │       ├── ft_isprint.c
│   │       ├── ft_itoa.c
│   │       ├── ft_lstadd_back_bonus.c
│   │       ├── ft_lstadd_front_bonus.c
│   │       ├── ft_lstclear_bonus.c
│   │       ├── ft_lstdelone_bonus.c
│   │       ├── ft_lstiter_bonus.c
│   │       ├── ft_lstlast_bonus.c
│   │       ├── ft_lstmap_bonus.c
│   │       ├── ft_lstnew_bonus.c
│   │       ├── ft_lstsize_bonus.c
│   │       ├── ft_memchr.c
│   │       ├── ft_memcmp.c
│   │       ├── ft_memcpy.c
│   │       ├── ft_memmove.c
│   │       ├── ft_memset.c
│   │       ├── ft_printf.c
│   │       ├── ft_ptr.c
│   │       ├── ft_putchar_fd.c
│   │       ├── ft_putendl_fd.c
│   │       ├── ft_putnbrbase.c
│   │       ├── ft_putnbr_fd.c
│   │       ├── ft_putstr.c
│   │       ├── ft_putstr_fd.c
│   │       ├── ft_split.c
│   │       ├── ft_strchr.c
│   │       ├── ft_strdup.c
│   │       ├── ft_striteri.c
│   │       ├── ft_strjoin.c
│   │       ├── ft_strlcat.c
│   │       ├── ft_strlcpy.c
│   │       ├── ft_strlen.c
│   │       ├── ft_strmapi.c
│   │       ├── ft_strncmp.c
│   │       ├── ft_strnstr.c
│   │       ├── ft_strrchr.c
│   │       ├── ft_strtrim.c
│   │       ├── ft_substr.c
│   │       ├── ft_tolower.c
│   │       ├── ft_toupper.c
│   │       ├── get_next_line.c
│   │       └── get_next_line_utils.c
│   ├── Makefile
│   ├── minilibx-linux
│   │   ├── configure
│   │   ├── LICENSE
│   │   ├── Makefile
│   │   ├── Makefile.gen
│   │   ├── Makefile.mk
│   │   ├── man
│   │   │   ├── man1
│   │   │   │   ├── mlx.1
│   │   │   │   ├── mlx_loop.1
│   │   │   │   ├── mlx_new_image.1
│   │   │   │   ├── mlx_new_window.1
│   │   │   │   └── mlx_pixel_put.1
│   │   │   └── man3
│   │   │       ├── mlx.3
│   │   │       ├── mlx_loop.3
│   │   │       ├── mlx_new_image.3
│   │   │       ├── mlx_new_window.3
│   │   │       └── mlx_pixel_put.3
│   │   ├── mlx_clear_window.c
│   │   ├── mlx_destroy_display.c
│   │   ├── mlx_destroy_image.c
│   │   ├── mlx_destroy_window.c
│   │   ├── mlx_expose_hook.c
│   │   ├── mlx_ext_randr.c
│   │   ├── mlx_flush_event.c
│   │   ├── mlx_get_color_value.c
│   │   ├── mlx_get_data_addr.c
│   │   ├── mlx.h
│   │   ├── mlx_hook.c
│   │   ├── mlx_init.c
│   │   ├── mlx_int_anti_resize_win.c
│   │   ├── mlx_int_do_nothing.c
│   │   ├── mlx_int_get_visual.c
│   │   ├── mlx_int.h
│   │   ├── mlx_int_param_event.c
│   │   ├── mlx_int_set_win_event_mask.c
│   │   ├── mlx_int_str_to_wordtab.c
│   │   ├── mlx_int_wait_first_expose.c
│   │   ├── mlx_key_hook.c
│   │   ├── mlx_lib_xpm.c
│   │   ├── mlx_loop.c
│   │   ├── mlx_loop_hook.c
│   │   ├── mlx_mouse.c
│   │   ├── mlx_mouse_hook.c
│   │   ├── mlx_new_image.c
│   │   ├── mlx_new_window.c
│   │   ├── mlx_pixel_put.c
│   │   ├── mlx_put_image_to_window.c
│   │   ├── mlx_rgb.c
│   │   ├── mlx_screen_size.c
│   │   ├── mlx_set_font.c
│   │   ├── mlx_string_put.c
│   │   ├── mlx_xpm.c
│   │   ├── mlx_xpm.c.ok
│   │   ├── README.md
│   │   ├── rgb2c.pl
│   │   └── test
│   │       ├── main.c
│   │       ├── Makefile.gen
│   │       ├── Makefile.mk
│   │       ├── new_win.c
│   │       ├── open24.xpm
│   │       ├── open30.xpm
│   │       ├── open.xpm
│   │       └── run_tests.sh
│   ├── pj
│   │   └── finalizing
│   ├── src
│   │   ├── add_parse.c
│   │   ├── ambient_parse.c
│   │   ├── camera_parse.c
│   │   ├── cylinder_measures.c
│   │   ├── cylinder_parse.c
│   │   ├── cylinder_vector.c
│   │   ├── data_clean.c
│   │   ├── file_copy.c
│   │   ├── infile_handle.c
│   │   ├── init.c
│   │   ├── light_parse.c
│   │   ├── main.c
│   │   ├── nls_parse.c
│   │   ├── parse.c
│   │   ├── parse_coord.c
│   │   ├── parse_or.c
│   │   ├── plane_coord.c
│   │   ├── plane_parse.c
│   │   ├── plane_vect.c
│   │   ├── spcoord.c
│   │   ├── sphere_parse.c
│   │   └── utils.c
│   └── test_files
│       ├── 10_invalid_plane_normal.rt
│       ├── 11_invalid_cylinder.rt
│       ├── 12_invalid_format.rt
│       ├── 13_extra_daat.rt
│       ├── 14_empty.rt
│       ├── 15_invalid_identifier.rt
│       ├── 1_missing_ambient.rt
│       ├── 2_multiple_ambient.rt
│       ├── 3_invalid_ratio.rt
│       ├── 4_invalid_rgb.rt
│       ├── 5_invalid_fov.rt
│       ├── 6_invalid_normal.rt
│       ├── 7_invalid_brightness.rt
│       ├── 8_missing_element_info.rt
│       ├── 9_invalid_sphere.rt
│       ├── example.rt
│       ├── invalid.rt
│       ├── plane_test.rt
│       └── sphere_test.rt
├── renderer
│   ├── includes
│   │   └── minirt.h
│   ├── Makefile
│   ├── mlx_linux
│   │   ├── configure
│   │   ├── LICENSE
│   │   ├── Makefile
│   │   ├── Makefile.gen
│   │   ├── Makefile.mk
│   │   ├── man
│   │   │   ├── man1
│   │   │   │   ├── mlx.1
│   │   │   │   ├── mlx_loop.1
│   │   │   │   ├── mlx_new_image.1
│   │   │   │   ├── mlx_new_window.1
│   │   │   │   └── mlx_pixel_put.1
│   │   │   └── man3
│   │   │       ├── mlx.3
│   │   │       ├── mlx_loop.3
│   │   │       ├── mlx_new_image.3
│   │   │       ├── mlx_new_window.3
│   │   │       └── mlx_pixel_put.3
│   │   ├── mlx_clear_window.c
│   │   ├── mlx_destroy_display.c
│   │   ├── mlx_destroy_image.c
│   │   ├── mlx_destroy_window.c
│   │   ├── mlx_expose_hook.c
│   │   ├── mlx_ext_randr.c
│   │   ├── mlx_flush_event.c
│   │   ├── mlx_get_color_value.c
│   │   ├── mlx_get_data_addr.c
│   │   ├── mlx.h
│   │   ├── mlx_hook.c
│   │   ├── mlx_init.c
│   │   ├── mlx_int_anti_resize_win.c
│   │   ├── mlx_int_do_nothing.c
│   │   ├── mlx_int_get_visual.c
│   │   ├── mlx_int.h
│   │   ├── mlx_int_param_event.c
│   │   ├── mlx_int_set_win_event_mask.c
│   │   ├── mlx_int_str_to_wordtab.c
│   │   ├── mlx_int_wait_first_expose.c
│   │   ├── mlx_key_hook.c
│   │   ├── mlx_lib_xpm.c
│   │   ├── mlx_loop.c
│   │   ├── mlx_loop_hook.c
│   │   ├── mlx_mouse.c
│   │   ├── mlx_mouse_hook.c
│   │   ├── mlx_new_image.c
│   │   ├── mlx_new_window.c
│   │   ├── mlx_pixel_put.c
│   │   ├── mlx_put_image_to_window.c
│   │   ├── mlx_rgb.c
│   │   ├── mlx_screen_size.c
│   │   ├── mlx_set_font.c
│   │   ├── mlx_string_put.c
│   │   ├── mlx_xpm.c
│   │   ├── mlx_xpm.c.ok
│   │   ├── README.md
│   │   ├── rgb2c.pl
│   │   └── test
│   │       ├── main.c
│   │       ├── Makefile.gen
│   │       ├── Makefile.mk
│   │       ├── new_win.c
│   │       ├── open24.xpm
│   │       ├── open30.xpm
│   │       ├── open.xpm
│   │       └── run_tests.sh
│   └── src
│       ├── camera.c
│       ├── color.c
│       ├── intersection.c
│       ├── mlx_func.c
│       ├── normal_vector.c
│       ├── ray_tracing.c
│       ├── root.c
│       ├── shading.c
│       ├── surface_normale.c
│       ├── tools.c
│       ├── vector2.c
│       ├── vector.c
│       └── world.c
└── todo

22 directories, 237 files

# Parsing Makefile
NAME = miniRT
CC = gcc
CFLAGS = -Wall -Wextra -Werror #-lm -lmlx -lXext -lX11
RM = rm -f

OBJ_DIR = ./obj/
SRC_DIR = ./src/
INC_DIR = ./includes/
LIBFT = ./libft
MINILIBX = ./minilibx-linux/

# Source files
SRCS = main.c infile_handle.c file_copy.c \
		nls_parse.c init.c utils.c ambient_parse.c \
		parse.c camera_parse.c parse_coord.c \
		parse_or.c light_parse.c plane_parse.c \
		plane_vect.c plane_coord.c data_clean.c \
		sphere_parse.c spcoord.c cylinder_parse.c \
		cylinder_measures.c cylinder_vector.c add_parse.c

OBJ = $(SRCS:$(SRC_DIR)%.c=$(OBJ_DIR)%.o)
INCS = minirt.h
IFLAGS = -I$(INC_DIR) -I$(LIBFT)/Includes
LFLAGS = -L$(LIBFT) -lft -L $(MINILIBX) -lmlx -lm -lXext -lX11
DB_FLAGS = -g3

# Add full path for sources
SRCS := $(addprefix $(SRC_DIR), $(SRCS))

all: $(NAME)

debug: CFLAGS += $(DB_FLAGS)
debug: re

$(NAME): $(OBJ_DIR) $(OBJ)
	@echo "\033[1;32mBuilding $@\033[0m\n"
	$(MAKE) -C $(LIBFT) --no-print-directory
	$(MAKE) -C $(MINILIBX) --no-print-directory
	$(CC) -o $@ $(OBJ) $(LFLAGS) $(CFLAGS)
	@echo "\033[1;32mDone ✅\033[0m\n"

$(OBJ_DIR)%.o: $(SRC_DIR)%.c $(addprefix $(INC_DIR), $(INCS))
	@echo "\033[1;33mCompiling $<\033[0m\n"
	@mkdir -p $(OBJ_DIR)
	@$(CC) $(CFLAGS) -c $(IFLAGS) -o $@ $<
	@echo "\033[1;33mDone ✅\033[0m\n"

$(OBJ_DIR):
	@echo "\033[1;34mCreating $(OBJ_DIR)\033[0m\n"
	@mkdir -p $(OBJ_DIR)
	@echo "\033[1;34mDone ✅\033[0m\n"

clean:
	@echo "\033[1;31mCleaning object files...\033[0m"
	@$(MAKE) -C $(LIBFT) --no-print-directory clean
	@$(MAKE) -C $(MINILIBX) --no-print-directory clean
	@$(RM) -r $(OBJ_DIR)
	@echo "\033[1;31mDone ✅\033[0m\n"

fclean: clean
	@echo "\033[1;31mFull clean, removing binaries...\033[0m"
	@$(MAKE) -C $(LIBFT) --no-print-directory fclean
	@$(MAKE) -C $(MINILIBX) --no-print-directory clean
	@$(RM) -f $(NAME)
	@echo "\033[1;31mDone ✅\033[0m\n"

re: fclean all

.PHONY: all debug clean fclean re $(OBJ_DIR)

#Rendering Makefile


NAME=miniRT

SRC= src/root.c \
 	src/tools.c \
  src/vector.c src/normal_vector.c\
	src/vector2.c src/ray_tracing.c \
	 src/intersection.c src/mlx_func.c\
	src/camera.c src/color.c src/surface_normale.c\
	src/world.c src/shading.c \
	
OBJ = ${SRC:.c=.o}

CC = gcc

%.o: %.c
	make -C mlx_linux
	$(CC) -Wall -Wextra -Werror -I/usr/include -Imlx_linux -c $< -o $@

all : ${NAME}

$(NAME) : $(OBJ)
	$(CC) $(OBJ) -Lmlx_linux -lmlx_Linux -L/usr/lib -Imlx_linux -lXext -lX11 -lm -lz -o $(NAME)

clean :
	make -C mlx_linux clean
	rm -f ${OBJ}

fclean : clean
	rm -f ${NAME}

re : fclean all

.PHONY: all clean fclean re

## Mains :
// parsing
int	main(int argc, char **argv)
{
	int		fd;
	t_file	*copy;
	t_data	*data;
	int		err;

	err = 0;
	fd = handle_file_error(argc, argv);
	copy = copy_file(fd);
	remove_nls(&copy);
	data = init_data();
	if (!data)
	{
		free(data);
		clean_content(copy);
		return (1);
	}
	err = parse_file(copy, data);
	custom_err(err);
	clean_content(copy);
	data_clean(data);
	return (0);
}

//rendering
int	main()
{
	t_scene	*sc;

	sc = malloc(sizeof(t_scene));
	if (sc == NULL)
		return 0;
	put_l(sc);
	put_a(sc);
	put_c(sc);
	
	t_vec dir = make_vec(0,0,0);
	t_vec center = make_vec(-0.5, 0.25, 0);
	t_vec color  = make_vec(255, 80, 80);
	t_vec d  = make_vec(0.5, 0, 0);
	int type = SP;
	make_list(&sc->objs, dir, center, color,d, type);

	t_vec a = make_vec(0,0,0);
	t_vec b = make_vec(0.5, 0.25, -0.5);
	t_vec e  = make_vec(80, 255, 80);
	t_vec r  = make_vec(0.5, 0, 0);
	int y = SP;
	make_list(&sc->objs, a, b, e, r, y);

	/*	t_vec B = make_vec(0,0,0);
	t_vec E = make_vec(0.5, 0.5, 0.5);
	t_vec R  = make_vec(80, 80, 255);
	t_vec A  = make_vec(1, 0, 0);
	int Y = SP;
	make_list(&sc->objs, B, E, R, A, Y);*/


	t_vec di = make_vec(0,1,0);
	t_vec c = make_vec(0, 0, 0);
	t_vec co  = make_vec(128, 128, 128);
	t_vec D  = make_vec(0, 0, 0);
	int t = PL;
	make_list(&sc->objs, di, c, co,D, t);

		t_vec dp = make_vec(0,-1,0);
	t_vec dc = make_vec(0, 2, 0);
	t_vec dr  = make_vec(128, 128, 128);
	t_vec dd  = make_vec(0, 0, 0);
	int dt = PL;
	make_list(&sc->objs, dp, dc, dr, dd, dt);

		t_vec d1 = make_vec(-1,0,0);
	t_vec d2 = make_vec(1, 0, 0);
	t_vec d3  = make_vec(255, 20, 20);
	t_vec d4  = make_vec(0, 0, 0);
	int d5 = PL;
	make_list(&sc->objs, d1, d2, d3,d4, d5);

		t_vec a1 = make_vec(1,0,0);
	t_vec a2 = make_vec(-1, 0, 0);
	t_vec a3  = make_vec(20, 255, 20);
	t_vec a4  = make_vec(0, 0, 0);
	int a5 = PL;
	make_list(&sc->objs, a1, a2, a3,a4, a5);



	/*t_vec i = make_vec(0,0,1);
	t_vec C = make_vec(50, 0, 20.6);
	t_vec col  = make_vec(10, 0, 128);
	t_vec Da  = make_vec(14.2, 21.42, 0);
	int ty = CY;
	make_list(&sc->objs, i, C, col,Da, ty);*/


	t_vec c1 = make_vec(1,0,0);
	t_vec c2 = make_vec(0.5, 0.5, 0.5);
	t_vec c3  = make_vec(10, 0, 255);
	t_vec c4  = make_vec(1.2, 10, 0);
	int c5 = CY;
	make_list(&sc->objs, c1, c2, c3,c4, c5);


		t_vec ni = make_vec(0,0,-1);
	t_vec nC = make_vec(0, 0, 1);
	t_vec ncol  = make_vec(128, 128, 128);
	t_vec nDa  = make_vec(0, 0, 0);
	int nty = PL;
	make_list(&sc->objs, ni, nC, ncol,nDa, nty);


		t_vec m = make_vec(1,0,0);
	t_vec m1 = make_vec(0.51, 0.51, 0.51);
	t_vec m2  = make_vec(10, 0, 255);
	t_vec m3  = make_vec(0, 0, 0);
	int m4 = 8;
	make_list(&sc->objs, m, m1, m2,m3, m4);

	ft_render(sc);
	return (0);
}

## Both headers 
## parsing 
#ifndef MINIRT_H
# define MINIRT_H
# include "libft.h"
# include <fcntl.h> // for open, close
# include <math.h>  // for math functions
# include <stdbool.h>
# include <stdio.h>  // for printf, perror
# include <stdlib.h> // for malloc, free, exit
# include <string.h> // for strerror
# include <unistd.h> // for read, write, close

# define DLIMIT 2000 // DIAMETERS
# define NDLIMIT 1
# define RT_CHARSET "-., \n"
# define POS_XYZLIMIT 1200.0
# define NEG_XYZLIMIT -800.0

typedef t_list			t_file;
typedef struct s_ambient
{
	bool				set;
	bool				unique;
	float				ratio;
	int					rgb[3];
}						t_amb;

typedef struct s_camera
{
	bool				set;
	bool				unique;
	float				x;
	float				y;
	float				z;
	float				ox;
	float				oy;
	float				oz;
	int					fov;
}						t_camera;

typedef struct s_light
{
	bool				set;
	bool				unique;
	float				x;
	float				y;
	float				z;
	float				brightness;
}						t_light;

typedef struct s_sphere
{
	float				x;
	float				y;
	float				z;
	float				diameter;
	int					rgb[3];
	struct s_sphere		*next;
}						t_sphere;

typedef struct s_plane
{
	float				x;
	float				y;
	float				z;
	float				ox;
	float				oy;
	float				oz;
	int					rgb[3];
	struct s_plane		*next;
}						t_plane;

typedef struct s_cylinder
{
	float				x;
	float				y;
	float				z;
	float				ox;
	float				oy;
	float				oz;
	float				diameter;
	float				height;
	int					rgb[3];
	struct s_cylinder	*next;
}						t_cylinder;

typedef struct s_data
{
	struct s_ambient	ambient;
	struct s_camera		camera;
	struct s_light		light;
	struct s_sphere		*sphere;
	struct s_plane		*plane;
	struct s_cylinder	*cylinder;
}						t_data;

float					ft_atof(const char *nptr);
int						fill_file_copy(int fd, t_file **file_copy);
t_file					*copy_file(int fd);
int						handle_file_error(int argc, char **argv);
int						check_file_ext(char *str, char *sub);
void					clean_content(t_file *rt);
void					remove_current(t_file **file_copy, t_file *current);
void					remove_nl(t_file **copy);
void					remove_space(t_file **copy);
int						remove_extra_spaces(char *str);
void					remove_nls(t_file **copy);
t_data					*init_data(void);
int						check_float(char *line, char end_char);
int						check_int(char *line, char end_char);
int						parse_file(t_file *copy, t_data *data);
// Uniques
int						ambient_parse(char *line, t_data *data);
int						camera_parse(char *line, t_data *data);
int						parse_aratio(int *cursor, char *line, t_data *data);
int						parse_argb(int *cursor, char *line, t_data *data);
int						parse_file(t_file *copy, t_data *data);
int						parse_line(char *line, t_data *data);
// cam
int						parse_orientation(int *cursor, char *line,
							t_data *data);
int						parse_camorientation(int *cursor, char *line,
							t_camera *camera, int i);
int						checkxyzlimit(int x, int y, int z);
int						parse_camera_coord(int *cursor, char *line,
							t_camera *camera, int i);
int						parse_coord(int *cursor, char *line, t_data *data);
int						parse_fov(int *cursor, char *line, t_data *data);
int						valid_orientation(float x, float y, float z);
// light
int						parse_lcoord(int *cursor, char *line, t_data *data);
int						light_parse(char *line, t_data *data);
int						parse_light_coord(int *cursor, char *line,
							t_light *light, int i);
// plane
int						plane_parse(char *line, t_data *data);
int						parse_pcoord(int *cursor, char *line, t_plane *current);
int						parse_pvect(int *cursor, char *line, t_plane *current);
int						parse_prgb(int *cursor, char *line, t_plane *current);
// sphere
int						parse_sphere_coord(int *cursor, char *line,
							t_sphere *current, int i);
int						parse_spcoord(int *cursor, char *line,
							t_sphere *current);
int						sphere_parse(char *line, t_data *data);
int						parse_diameter(int *cursor, char *line,
							t_sphere *current);
int						parse_sprgb(int *cursor, char *line, t_sphere *current);
// cylinder
int						parse_cyvect(int *cursor, char *line,
							t_cylinder *current);
int						parse_cycoord(int *cursor, char *line,
							t_cylinder *current);
int						parse_cyrgb(int *cursor, char *line,
							t_cylinder *current);
int						cylinder_parse(char *line, t_data *data);
t_cylinder				*get_current_cylinder(t_data *data);
int						parse_cymeasures(int *cursor, char *line,
							t_cylinder *current);
void					data_clean(t_data *data);
int						parse_cylinder_coord(int *cursor, char *line,
							t_cylinder *current, int i);
void					custom_err(int err);	
#endif%          
                                                                           
## Rendering

#ifndef MINIRT_H
# define MINIRT_H

# define WIDTH 1200
# define HEIGHT 800
# define EPS 0.000001
# define CY 1
# define PL 2
# define SP 3
# define CO 4 
# include <stdlib.h>
# include <unistd.h>
# include <stdio.h>
# include <fcntl.h>
# include <math.h>
# include "../mlx_linux/mlx.h"

typedef struct s_data {
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}	t_img_data;

typedef struct s_vars {
	void	*mlx;
	void	*win;
}				t_vars;

typedef struct s_vec
{
	double	x;
	double	y;
	double	z;
}	t_vec;

typedef struct s_inter
{
	double	t;
	t_vec	col;
	t_vec	hit;
	t_vec	norm;
}	t_inter;

typedef struct t_cam
{
	t_vec	cen;
	t_vec	dir;
	double	fov;
	int		count;
}	t_cam;

typedef struct s_light
{
	t_vec			src;
	double			ratio;
	t_vec			col;
	struct s_light	*next;
}	t_light;

typedef struct s_amb
{
	t_vec	col;
	double	ratio;
	int		count;
}	t_amb;

typedef struct s_objs
{
	int				type;
	t_vec			cen;
	t_vec			dir;
	t_vec			p;
	t_vec			col;
	t_vec			norm;
	struct s_objs	*next;
}	t_objs;

typedef struct s_scene
{
	t_vec	col;
	t_cam	cam;
	t_light	*light;
	t_amb	amb;
	t_objs	*objs;
}	t_scene;

typedef struct collector
{
	void				*adr;
	struct collector	*next;
}	t_collector;

/* camera */
typedef struct Camera_Setup
{
	t_vec		orig;
	t_vec		up;
	t_vec		right;
	t_vec		forward;
	double		height;
	double		width;
	double		aspect_r;
	double		theta;
}	t_camera;

typedef struct CamRay
{
	t_vec	origin;
	t_vec	dir;
}	t_CamRay;

/* rendring */
typedef struct render
{
	t_vars		vars;
	t_img_data	img;
	double		v;
	double		u;
	int			x;
	int			y;
	t_camera	cam;
	t_CamRay	ray_;
	t_vec		ray_col;
}	t_render;

// Intersection 

typedef struct sphere
{
	double	a;
	double	b;
	double	c;
	double	t;
	double	t1;
	double	t2;
	t_vec	oc;
}	t_sphere;

typedef struct cylinder
{
	double	a;
	double	b;
	double	c;
	double	t;
	double	t1;
	double	t2;
	double	delta;
	double	y0;
	double	y1;
	t_vec	oc;
	t_vec	normal;
}	t_cylinder;


//vectors
void		null_vec(t_vec *v);
t_vec		get_vec(char *s);
t_vec		get_color(char *s);
t_vec		get_normalized(t_vec v);
void		normalize(t_vec *v);
double		get_norm2(t_vec v);
t_vec		sub_vec(t_vec u, t_vec v);
t_vec		add_vec(t_vec u, t_vec v);
t_vec		mult_vec(t_vec v, double a);
t_vec		vect_cross(t_vec u, t_vec v);
double		dot_product(t_vec u, t_vec v);
double		module_v(t_vec	v);
t_vec		div_vect(t_vec v, double a);
t_vec		make_vec(double x, double y, double z);
void make_list(t_objs **head, t_vec dir, t_vec center, t_vec color, t_vec d, int type);
t_objs *alloc_obj(t_vec dir, t_vec center, t_vec color, t_vec d, int type);

/*rendring */
void		ft_render(t_scene *sc);
void    ft_err(char *err);

/* camera */
t_camera	set_camera(t_scene *sc);
t_CamRay	ray_primary(t_camera *cam, double v, double u);
t_vec		ray_at(t_CamRay *ray, double t);

/* intersections*/
double		take_min(double x, double y);
t_inter		find_inter(t_CamRay *ray, t_scene *sc);
double		inter_sphere(t_CamRay *ray, t_objs *sp);
double		inter_plane(t_CamRay *ray, t_objs *pl);
double		inter_cylinder(t_CamRay *ray, t_objs *cy);

/* mlx funct */
int			red_button(t_vars *vars);
int			handle_key(int key, t_vars *vars);
void		my_mlx_pixel_put(t_img_data *data, int x, int y, int color);

// color
t_vec		add_coef(t_vec col1, t_vec col2, double ratio);
int			create_rgb(int r, int g, int b);
t_vec		add_color(t_vec col1, t_vec col2);
t_vec		ray_color(t_CamRay *ray, t_scene *sc);
t_vec		colorize(double r, double g, double b);
t_vec		diffuse(t_inter inter, t_light *light, double d);
int			shade(t_scene *sc, t_inter inter, t_light *light);

//surface normal
int			is_inside(t_vec ray, t_vec norm);
t_inter		spher_normal(t_inter hold, t_objs *obj, t_CamRay *ray);
t_inter		plane_normal(t_inter hold, t_objs *obj, t_CamRay *ray);
t_inter		cylinder_normal(t_inter hold, t_objs *obj, t_CamRay *ray);

#endif%                   
